<!doctype html>
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" type="text/css" href="/static/style.css">
  <link rel="stylesheet" type="text/css" href="/static/pygments.css">

  <link rel="alternate" type="application/atom+xml" href="http://podoliaka.org/feed.xml" title="Roman Podoliaka's Blog">

  <title>The perils of temporary object lifetimes in C++</title>

  <meta name="author" content="Roman Podoliaka">
  

  

<body>

  <div class="header-wrapper">
  <header class="header">
    <img src="/static/logo.svg" alt="Logotype" class="logo">
    <a href="/" class="title">Roman Podoliaka's Blog</a>

    <nav>
      <a href="/about">about</a><a href="/talks">talks</a><a href="https://www.dropbox.com/s/j8n1yd86dn00a41/cv.pdf?dl=1">CV</a><a href="/feed.xml">feed</a>
    </nav>
  </header>
  </div> <!-- /.header-wrapper -->

  <div class="content-wrapper">
  <div id="content">
    
<article>
  <header>
    <h1>The perils of temporary object lifetimes in C++</h1>

    <div class="meta">
    
written by Roman Podoliaka on

<time datetime="2023-11-21T00:00:00+00:00">
  November 21, 2023
</time>





    </div>
  </header>

  <p>The other day my junior colleague asked me to help him troubleshoot a failing unit test: the
actual value of a protocol buffer string field did not match<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> the expected value, and he
couldn't understand why. Unfortunately, I'm not allowed to share the code, but it can be
summarized using this contrived example:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hello, programmer!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">foo</span><span class="p">()};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>A seasoned C++ programmer will immediately spot the problem, but someone who have only used a
memory-safe language like Java or Python in the past will be baffled why a seemingly trivial
program above may or may not print the string <code>"Hello, programmer!\n"</code> depending on the chosen
level of optimizations, the version of a compiler, operating system, etc.</p>
<p>The issue, of course, is that <code>foo()</code> returns a <em>temporary</em> object whose lifetime ends too early:</p>
<ul>
<li>
<p>unlike <code>std::string</code>, <code>std::string_view</code> does <em>not</em> allocate and own a dynamic array of <code>char</code>;
  instead, it <em>references</em> a contiguous sequence of <code>char</code> somewhere in main memory. In this case,
  that sequence is a dynamic array owned by the temporary <code>std::string</code> object</p>
</li>
<li>
<p>this temporary object is destroyed right after the initialization of a <code>std::string_view</code> value,
  and so the newly constructed <code>std::string_view</code> object immediately points to a memory region that
  has already been freed and, potentially, reused for something else</p>
</li>
</ul>
<p>How would a junior programmer know they made a mistake like that? Would the compiler be able to help?
I tried the latest versions of both clang++ and g++ available in Arch Linux, but neither complained
about the code above:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>clang++<span class="w"> </span>--version
clang<span class="w"> </span>version<span class="w"> </span><span class="m">16</span>.0.6
Target:<span class="w"> </span>x86_64-pc-linux-gnu
Thread<span class="w"> </span>model:<span class="w"> </span>posix
InstalledDir:<span class="w"> </span>/usr/bin
$<span class="w"> </span>clang++<span class="w"> </span>example.cpp<span class="w"> </span>-o<span class="w"> </span>example<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c++17
$

$<span class="w"> </span>g++<span class="w"> </span>--version
g++<span class="w"> </span><span class="o">(</span>GCC<span class="o">)</span><span class="w"> </span><span class="m">13</span>.2.1<span class="w"> </span><span class="m">20230801</span>
Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2023</span><span class="w"> </span>Free<span class="w"> </span>Software<span class="w"> </span>Foundation,<span class="w"> </span>Inc.
This<span class="w"> </span>is<span class="w"> </span>free<span class="w"> </span>software<span class="p">;</span><span class="w"> </span>see<span class="w"> </span>the<span class="w"> </span><span class="nb">source</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>copying<span class="w"> </span>conditions.<span class="w">  </span>There<span class="w"> </span>is<span class="w"> </span>NO
warranty<span class="p">;</span><span class="w"> </span>not<span class="w"> </span>even<span class="w"> </span><span class="k">for</span><span class="w"> </span>MERCHANTABILITY<span class="w"> </span>or<span class="w"> </span>FITNESS<span class="w"> </span>FOR<span class="w"> </span>A<span class="w"> </span>PARTICULAR<span class="w"> </span>PURPOSE.
$<span class="w"> </span>g++<span class="w"> </span>example.cpp<span class="w"> </span>-o<span class="w"> </span>example<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c++17
$
</code></pre></div>

<p>Interestingly, replacing <code>std::string_view bar = {foo()};</code> with <code>std::string_view bar = foo();</code> makes
the difference, and clang++ is now able to generate a warning (that can be turned into an error if you
compile the code with <code>-Werror</code>):</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>clang++<span class="w"> </span>example.cpp<span class="w"> </span>-o<span class="w"> </span>example<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c++17
example.cpp:9:28:<span class="w"> </span>error:<span class="w"> </span>object<span class="w"> </span>backing<span class="w"> </span>the<span class="w"> </span>pointer<span class="w"> </span>will<span class="w"> </span>be<span class="w"> </span>destroyed<span class="w"> </span>at<span class="w"> </span>the<span class="w"> </span>end<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>full-expression<span class="w"> </span><span class="o">[</span>-Werror,-Wdangling-gsl<span class="o">]</span>
<span class="w">    </span>std::string_view<span class="w"> </span><span class="nv">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>foo<span class="o">()</span><span class="p">;</span>
<span class="w">                           </span>^~~~~
<span class="m">1</span><span class="w"> </span>error<span class="w"> </span>generated.
</code></pre></div>

<p><a href="https://en.cppreference.com/w/cpp/language/initialization">C++ initialization rules</a> are mind-boggling, but
it looks like list-initialization somehow throws clang++ off, while diagnostics in g++ are even weaker.</p>
<p>Not all hope is lost, though. While it might be hard to detect this issue at <em>compile</em> time, it is certainly
possible to do so at <em>runtime</em>. <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a>
is a huge step forward and truly is a must have if you write C/C++ these days. Passing <code>-fsanitize=address</code> when
compiling binaries using clang or GCC will add the necessary instrumentation to detect such errors, for example:</p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span>clang++<span class="w"> </span>example.cpp<span class="w"> </span>-o<span class="w"> </span>example<span class="w"> </span>-Wall<span class="w"> </span>-Werror<span class="w"> </span>-pedantic<span class="w"> </span>-std<span class="o">=</span>c++17<span class="w"> </span>-g<span class="w"> </span>-Og<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-fno-omit-frame-pointer
$<span class="w"> </span>./example
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">795293</span><span class="o">==</span>ERROR:<span class="w"> </span>AddressSanitizer:<span class="w"> </span>heap-use-after-free<span class="w"> </span>on<span class="w"> </span>address<span class="w"> </span>0x603000000040<span class="w"> </span>at<span class="w"> </span>pc<span class="w"> </span>0x55a69bd7cd75<span class="w"> </span>bp<span class="w"> </span>0x7ffee39bfff0<span class="w"> </span>sp<span class="w"> </span>0x7ffee39bf7b0
READ<span class="w"> </span>of<span class="w"> </span>size<span class="w"> </span><span class="m">18</span><span class="w"> </span>at<span class="w"> </span>0x603000000040<span class="w"> </span>thread<span class="w"> </span>T0
<span class="w">    </span><span class="c1">#0 0x55a69bd7cd74 in __interceptor_fwrite.part.0 asan_interceptors.cpp.o</span>
<span class="w">    </span><span class="c1">#1 0x7f17373489e4 in std::basic_streambuf&lt;char, std::char_traits&lt;char&gt;&gt;::sputn(char const*, long) /usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:458:28</span>
<span class="w">    </span><span class="c1">#2 0x7f17373489e4 in void std::__ostream_write&lt;char, std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;, char const*, long) /usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:53:52</span>
<span class="w">    </span><span class="c1">#3 0x7f17373489e4 in std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;, char const*, long) /usr/src/debug/gcc/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:104:18</span>
<span class="w">    </span><span class="c1">#4 0x55a69be6466d in std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp; std::operator&lt;&lt;&lt;char, std::char_traits&lt;char&gt;&gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt;&gt;&amp;, std::basic_string_view&lt;char, std::char_traits&lt;char&gt;&gt;) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string_view:762:14</span>
<span class="w">    </span><span class="c1">#5 0x55a69be6466d in main /home/malor/sandbox/example.cpp:10:15</span>
<span class="w">    </span><span class="c1">#6 0x7f1737045ccf  (/usr/lib/libc.so.6+0x27ccf) (BuildId: 8bfe03f6bf9b6a6e2591babd0bbc266837d8f658)</span>
<span class="w">    </span><span class="c1">#7 0x7f1737045d89 in __libc_start_main (/usr/lib/libc.so.6+0x27d89) (BuildId: 8bfe03f6bf9b6a6e2591babd0bbc266837d8f658)</span>
<span class="w">    </span><span class="c1">#8 0x55a69bd2b0d4 in _start (/home/malor/sandbox/example+0x1e0d4) (BuildId: c4ea059bae95830d2bf5f9b4963447a6f11ab751)</span>

0x603000000040<span class="w"> </span>is<span class="w"> </span>located<span class="w"> </span><span class="m">0</span><span class="w"> </span>bytes<span class="w"> </span>inside<span class="w"> </span>of<span class="w"> </span><span class="m">19</span>-byte<span class="w"> </span>region<span class="w"> </span><span class="o">[</span>0x603000000040,0x603000000053<span class="o">)</span>
freed<span class="w"> </span>by<span class="w"> </span>thread<span class="w"> </span>T0<span class="w"> </span>here:
<span class="w">    </span><span class="c1">#0 0x55a69be61fba in operator delete(void*) (/home/malor/sandbox/example+0x154fba) (BuildId: c4ea059bae95830d2bf5f9b4963447a6f11ab751)</span>
<span class="w">    </span><span class="c1">#1 0x55a69be6464e in std::__new_allocator&lt;char&gt;::deallocate(char*, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/new_allocator.h:168:2</span>
<span class="w">    </span><span class="c1">#2 0x55a69be6464e in std::allocator&lt;char&gt;::deallocate(char*, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/allocator.h:210:25</span>
<span class="w">    </span><span class="c1">#3 0x55a69be6464e in std::allocator_traits&lt;std::allocator&lt;char&gt;&gt;::deallocate(std::allocator&lt;char&gt;&amp;, char*, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:516:13</span>
<span class="w">    </span><span class="c1">#4 0x55a69be6464e in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::_M_destroy(unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:289:9</span>
<span class="w">    </span><span class="c1">#5 0x55a69be6464e in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::_M_dispose() /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:283:4</span>
<span class="w">    </span><span class="c1">#6 0x55a69be6464e in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::~basic_string() /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:792:9</span>
<span class="w">    </span><span class="c1">#7 0x55a69be6464e in main /home/malor/sandbox/example.cpp:9:28</span>
<span class="w">    </span><span class="c1">#8 0x7f1737045ccf  (/usr/lib/libc.so.6+0x27ccf) (BuildId: 8bfe03f6bf9b6a6e2591babd0bbc266837d8f658)</span>

previously<span class="w"> </span>allocated<span class="w"> </span>by<span class="w"> </span>thread<span class="w"> </span>T0<span class="w"> </span>here:
<span class="w">    </span><span class="c1">#0 0x55a69be61522 in operator new(unsigned long) (/home/malor/sandbox/example+0x154522) (BuildId: c4ea059bae95830d2bf5f9b4963447a6f11ab751)</span>
<span class="w">    </span><span class="c1">#1 0x55a69be645b1 in std::__new_allocator&lt;char&gt;::allocate(unsigned long, void const*) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/new_allocator.h:147:27</span>
<span class="w">    </span><span class="c1">#2 0x55a69be645b1 in std::allocator&lt;char&gt;::allocate(unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/allocator.h:198:32</span>
<span class="w">    </span><span class="c1">#3 0x55a69be645b1 in std::allocator_traits&lt;std::allocator&lt;char&gt;&gt;::allocate(std::allocator&lt;char&gt;&amp;, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:482:20</span>
<span class="w">    </span><span class="c1">#4 0x55a69be645b1 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::_S_allocate(std::allocator&lt;char&gt;&amp;, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:126:16</span>
<span class="w">    </span><span class="c1">#5 0x55a69be645b1 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::_M_create(unsigned long&amp;, unsigned long) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.tcc:155:14</span>
<span class="w">    </span><span class="c1">#6 0x55a69be645b1 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::_M_construct&lt;char const*&gt;(char const*, char const*, std::forward_iterator_tag) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.tcc:225:14</span>
<span class="w">    </span><span class="c1">#7 0x55a69be645b1 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;::basic_string&lt;std::allocator&lt;char&gt;&gt;(char const*, std::allocator&lt;char&gt; const&amp;) /usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:639:2</span>
<span class="w">    </span><span class="c1">#8 0x55a69be645b1 in foo[abi:cxx11]() /home/malor/sandbox/example.cpp:5:12</span>
<span class="w">    </span><span class="c1">#9 0x55a69be645b1 in main /home/malor/sandbox/example.cpp:9:29</span>
<span class="w">    </span><span class="c1">#10 0x7f1737045ccf  (/usr/lib/libc.so.6+0x27ccf) (BuildId: 8bfe03f6bf9b6a6e2591babd0bbc266837d8f658)</span>

SUMMARY:<span class="w"> </span>AddressSanitizer:<span class="w"> </span>heap-use-after-free<span class="w"> </span>asan_interceptors.cpp.o<span class="w"> </span><span class="k">in</span><span class="w"> </span>__interceptor_fwrite.part.0
Shadow<span class="w"> </span>bytes<span class="w"> </span>around<span class="w"> </span>the<span class="w"> </span>buggy<span class="w"> </span>address:
<span class="w">  </span>0x602ffffffd80:<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span>
<span class="w">  </span>0x602ffffffe00:<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span>
<span class="w">  </span>0x602ffffffe80:<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span>
<span class="w">  </span>0x602fffffff00:<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span>
<span class="w">  </span>0x602fffffff80:<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="nv">00</span>
<span class="o">=</span>&gt;0x603000000000:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span><span class="m">00</span><span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="o">[</span>fd<span class="o">]</span>fd<span class="w"> </span>fd<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
<span class="w">  </span>0x603000000080:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
<span class="w">  </span>0x603000000100:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
<span class="w">  </span>0x603000000180:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
<span class="w">  </span>0x603000000200:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
<span class="w">  </span>0x603000000280:<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa<span class="w"> </span>fa
Shadow<span class="w"> </span>byte<span class="w"> </span>legend<span class="w"> </span><span class="o">(</span>one<span class="w"> </span>shadow<span class="w"> </span>byte<span class="w"> </span>represents<span class="w"> </span><span class="m">8</span><span class="w"> </span>application<span class="w"> </span>bytes<span class="o">)</span>:
<span class="w">  </span>Addressable:<span class="w">           </span><span class="m">00</span>
<span class="w">  </span>Partially<span class="w"> </span>addressable:<span class="w"> </span><span class="m">01</span><span class="w"> </span><span class="m">02</span><span class="w"> </span><span class="m">03</span><span class="w"> </span><span class="m">04</span><span class="w"> </span><span class="m">05</span><span class="w"> </span><span class="m">06</span><span class="w"> </span><span class="m">07</span><span class="w"> </span>
<span class="w">  </span>Heap<span class="w"> </span>left<span class="w"> </span>redzone:<span class="w">       </span>fa
<span class="w">  </span>Freed<span class="w"> </span>heap<span class="w"> </span>region:<span class="w">       </span>fd
<span class="w">  </span>Stack<span class="w"> </span>left<span class="w"> </span>redzone:<span class="w">      </span>f1
<span class="w">  </span>Stack<span class="w"> </span>mid<span class="w"> </span>redzone:<span class="w">       </span>f2
<span class="w">  </span>Stack<span class="w"> </span>right<span class="w"> </span>redzone:<span class="w">     </span>f3
<span class="w">  </span>Stack<span class="w"> </span>after<span class="w"> </span><span class="k">return</span>:<span class="w">      </span>f5
<span class="w">  </span>Stack<span class="w"> </span>use<span class="w"> </span>after<span class="w"> </span>scope:<span class="w">   </span>f8
<span class="w">  </span>Global<span class="w"> </span>redzone:<span class="w">          </span>f9
<span class="w">  </span>Global<span class="w"> </span>init<span class="w"> </span>order:<span class="w">       </span>f6
<span class="w">  </span>Poisoned<span class="w"> </span>by<span class="w"> </span>user:<span class="w">        </span>f7
<span class="w">  </span>Container<span class="w"> </span>overflow:<span class="w">      </span><span class="nb">fc</span>
<span class="w">  </span>Array<span class="w"> </span>cookie:<span class="w">            </span>ac
<span class="w">  </span>Intra<span class="w"> </span>object<span class="w"> </span>redzone:<span class="w">    </span>bb
<span class="w">  </span>ASan<span class="w"> </span>internal:<span class="w">           </span>fe
<span class="w">  </span>Left<span class="w"> </span>alloca<span class="w"> </span>redzone:<span class="w">     </span>ca
<span class="w">  </span>Right<span class="w"> </span>alloca<span class="w"> </span>redzone:<span class="w">    </span><span class="nv">cb</span>
<span class="o">==</span><span class="nv">795293</span><span class="o">==</span>ABORTING
</code></pre></div>

<p>AddressSanitizer detected the issue at runtime and immediately aborted execution of the program.
Its output will contain the following information:</p>
<ul>
<li>
<p>the type of a memory error and where it happened. In this case, it's <code>heap-use-after-free</code><sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup> that
  is triggered inside <code>operator&lt;&lt;()</code> which tries to access already freed memory through a dangling pointer</p>
</li>
<li>
<p>where in the code this memory block was previously allocated and deallocated</p>
</li>
<li>
<p>AddressSanitizer's view of main memory
  (<a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">read</a> about how AddressSanitizer
  works to make sense of this output)</p>
</li>
</ul>
<p>(note the use of <code>-g -Og -fno-omit-frame-pointer</code> to produce detailed stack traces with source code line numbers).</p>
<p>The catch is that the faulty code path must be triggered in order for AddressSanitizer to do its job.
Hey, but that's why you should always write tests!</p>
<p>It <em>is</em> amazing to me how easy it is to make a mistake like that in C++ compared to programming languages
with automatic memory management, or programming languages like Rust that can detect those at <em>compile</em> time.
This also reminds me how old I am: we now have a whole new generation of programmers for whom automatic memory
management is the norm, and those pesky C++ object lifetime rules are some anachronisms.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>In addition to a test failure, there was a warning about protocol buffer string serialization detecting
an invalid UTF-8 sequence. When I pointed that out to my colleague (to hint that we were reading garbage memory
somehow), it didn't trigger any reaction. I now realize that we are living in the world where UTF-8 has officially
won and it is now universally associated with the term Unicode or even "text" -- no one cares what encoding
is used and how it works, as it's all UTF-8 these days.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>The string value in the example above was carefully chosen to trigger this specific kind of a memory error.
Modern implementations of <code>std::string</code> will store shorter strings on the stack, and heap won't be used at all.
This does not change the outcome, though: either way <code>std::string_view</code> would be referencing a memory block that
might already be used for storing something else. AddressSanitizer would detect that as <code>stack-use-after-scope</code>.&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div>

  <footer>
  
  
  </footer>
</article>

  </div> <!-- /#content -->
  </div> <!-- /.content-wrapper -->

  <div class="footer-wrapper">
  <footer class="footer">
    <p>&copy; 2023 Roman Podoliaka
</p>
  </footer>
  </div> <!-- /.footer-wrapper -->

  



<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37812430-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- /Google Analytics -->