<!doctype html>
<head>
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" type="text/css" href="/static/style.css">
  <link rel="stylesheet" type="text/css" href="/static/pygments.css">

  <link rel="alternate" type="application/atom+xml" href="http://podoliaka.org/feed.xml" title="Roman Podoliaka's Blog">

  <title>Iterators for Beginners. The Way of С++</title>

  <meta name="author" content="Roman Podoliaka">
  

  

<body>

  <div class="header-wrapper">
  <header class="header">
    <img src="/static/logo.svg" alt="Logotype" class="logo">
    <a href="/" class="title">Roman Podoliaka's Blog</a>

    <nav>
      <a href="/about">about</a><a href="/talks">talks</a><a href="https://www.dropbox.com/s/j8n1yd86dn00a41/cv.pdf?dl=1">CV</a><a href="/feed.xml">feed</a>
    </nav>
  </header>
  </div> <!-- /.header-wrapper -->

  <div class="content-wrapper">
  <div id="content">
    
<article>
  <header>
    <h1>Iterators for Beginners. The Way of С++</h1>

    <div class="meta">
    
written by Roman Podoliaka on

<time datetime="2013-01-20T00:00:00+00:00">
  January 20, 2013
</time>





    </div>
  </header>

  <h2>Foreword</h2>
<p>This post is mainly for beginners and is not intended to teach you everything
about iterators in <code>C++</code>. So if you know about <code>iterator_traits<></code> or something
like that you might get bored reading it. Anyway I hope this information will be
useful for the people who haven't heard about iterators before.</p>
<h2>The problem</h2>
<p>Lets consider the following problem: we need a function that would return an index of
the maximum element in a given array of integers. We could implement it like this:</p>
<pre class="code cpp literal-block">
<span class="kt">int</span> <span class="nf">max_element</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">max</span><span class="p">])</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>This code works perfectly but it has a huge limitation though - it works only for arrays of <code>int</code> elements.
To find a maximum element in an array of floats we would have to write completely the same code and
substitute <code>int</code> with <code>float</code> in the declaration of an array type. We all know that <code>C++</code> has
a solution for this problem - <em>templates</em>.</p>
<p>A generalized version of the function which returns an index of maximum element in an array of any type
(precisely, for which the relation <em>greater than</em> is defined):</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">max_element</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">max</span><span class="p">])</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Now we must be satisfied. But what if we wanted to search for the maximum element only in a small part of
the whole array?</p>
<p>Arrays in <code>C++</code> are linearly allocated memory segments filled with elements of some type with no gaps
between them. Moreover an array name is also a pointer to the first element of this array. Arrays and pointers
have many things in common and, as you may already know, it is perfectly ok to use pointer arithmetic to access
an array elements.</p>
<p>The elements range for the function to process is specified by two pointers: the first one points to the <em>first</em>
element to process (<code>begin</code>), the second one points to the <em>next after the last</em> element to process. So why have
we choosen an open range <code>[begin; end)</code>? This will allow us to write down the loop end condtion in a very clear
and obvious way.</p>
<p>The implementation is given below:</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">begin</span><span class="p">;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>Using this implementation one can find the maximum element both in the whole array and in any part of it:</p>
<pre class="code cpp literal-block">
<span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">max_element</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">array</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">max_of_first3</span> <span class="o">=</span> <span class="n">max_element</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">array</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</pre>
<h2>Can we do even better?</h2>
<p>Our generalized function works great for arrays of any type, but arrays have a few drawbacks:
one can't resize an existing array, one can't push a new element to the front of an array, etc.
It would be great to use the same code for searching of the maximum element in different kinds of
data structures, e. g. in a <a class="reference external" href="http://en.wikipedia.org/wiki/Linked_list">linked list</a>.</p>
<p>But elements of a linked list aren't allocated linearly in memory - they are separate chunks of
memory connected with each other using pointers (<em>links</em>). That means we can't use
our function anymore, because the way we access data structure elements has changed, though
the algorithm itself remains completely the same: visit all the elements one after another and
compare each one with the current maximum element.</p>
<p>What really has changed is the way we access data structure elements. For arrays we could use
pointers arithmetic to calculate the address of an element we want (<code>base address + index * sizeof(T)</code>).
But to access an <code>i-th</code> element of a linked list one should go from the <code>head</code> of the list
to the <code>(i-1)-th</code> element one by one using pointers stored in the list nodes.</p>
<p>So here is the problem with our function: <strong>the way we access elements of used data structure
is tightly coupled with the algorithm which is implemented by our function</strong>. That means
we have to write a separate version of our function for all data structures we want to use
it for. And we all know that code duplication is a really bad thing which leads to errors and
difficults during the process of refactoring.</p>
<p>To solve this problem we have to decouple the algorithm from a data structure it processes.</p>
<p>Lets have a look at our function:</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">max_element</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">begin</span><span class="p">;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>How do we access the array elements?</p>
<ol class="arabic simple">
<li><code>*</code> – <em>dereference a pointer</em> – get the value of an element the pointer points to.</li>
<li><code>!=</code> – <em>not equal</em> – compare two pointers (to detect the end of a range).</li>
<li><code>++</code> – <em>increment a pointer</em> – move the pointer to the next element of an array.</li>
</ol>
<p>If we pass some objects to the <code>max_element()</code> function instead of passing pointers,
we can define the operations given above for these objects in a way they implement the
logic of accessing elements of different data structures (e. g. a linked list).</p>
<p>It is easy to do using templates and operators overloading facilities of <code>C++</code>.</p>
<p>So the final version of our function looks like this:</p>
<pre class="code cpp literal-block">
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
<span class="n">Iterator</span> <span class="n">max_element</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Iterator</span> <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">begin</span><span class="p">;</span> <span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre>
<p>So here we use objects of template parameter class <code>Iterator</code> instead of pointers. So what's an
iterator?</p>
<p>An <strong>iterator</strong> is a special object which allows one to access a data structure elements without
exposing its internal implementation. One works with a data structure by the means of a well defined
abstract interface of iterators.</p>
<p><code>C++</code> iterators use pointers semantics as their interface, but that's just an
implementation detail. It is important that all containers provide iterators with the same interface.
Users work with containers using iterators and don't know anything about how the containers are
actually implemented. This is the way algorithms and data structures are decoupled - one can use
the same algorithm for different data structures without any changes of the code.</p>
<h2>Your first iterator</h2>
<p>Consider the simplest implementation of a singly linked list. The implementation of a list node:</p>
<pre class="code cpp literal-block">
<span class="cp">#ifndef __LIST_NODE_H__
#define __LIST_NODE_H__
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* __LIST_NODE_H__ */</span>
</pre>
<p>The implementation of a list container:</p>
<pre class="code cpp literal-block">
<span class="cp">#ifndef __LINKED_LIST_H__
#define __LINKED_LIST_H__
</span>
<span class="cp">#include</span> <span class="cpf">&quot;list_node.h&quot;</span><span class="cp">
#include</span> <span class="cpf">&quot;list_iterator.h&quot;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LinkedList</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">LinkedList</span><span class="p">();</span>
    <span class="o">~</span><span class="n">LinkedList</span><span class="p">();</span>

    <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_head</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_tail</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">LinkedList</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">_head</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_tail</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::~</span><span class="n">LinkedList</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">_head</span><span class="p">;</span>
        <span class="n">_head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">_head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
        <span class="n">_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">_tail</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">oldfirst</span> <span class="o">=</span> <span class="n">_head</span><span class="p">;</span>

        <span class="n">_head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">_head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
        <span class="n">_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldfirst</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_tail</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">_tail</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
        <span class="n">_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">_head</span> <span class="o">=</span> <span class="n">_tail</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">oldlast</span> <span class="o">=</span> <span class="n">_tail</span><span class="p">;</span>

        <span class="n">_tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">_tail</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">elem</span><span class="p">;</span>
        <span class="n">_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">oldlast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">_tail</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">begin</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">end</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __LINKED_LIST_H__ */</span>
</pre>
<p>We have implemented a minimal subset of list methods:</p>
<ul class="simple">
<li>data structure allocation/initialization and destruction/deallocation - <code>LinkedList()</code>, <code>~LinkedList()</code>;</li>
<li>adding of elements to the front and to the back of a list - <code>push_front()</code>, <code>push_back()</code>;</li>
<li>access to a list elements - methods that return iterators which point to the begin and to the
end of the list - <code>begin()</code>, <code>end()</code>.</li>
</ul>
<p>Using the iterators that are returned by <code>begin()/end()</code> pair one can access all the list elements.
The implementation of an iterator for a linked list data structure is given below:</p>
<pre class="code cpp literal-block">
<span class="cp">#ifndef __LIST_ITERATOR_H__
#define __LIST_ITERATOR_H__
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ListIterator</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListIterator</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">_currentNode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ListIterator</span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">_currentNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">node</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_currentNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_currentNode</span> <span class="o">=</span> <span class="n">_currentNode</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_currentNode</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">ListIterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_currentNode</span> <span class="o">!=</span> <span class="n">it</span><span class="p">.</span><span class="n">node</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __LIST_ITERATOR_H__ */</span>
</pre>
<p>An iterator instance is initialized with a pointer to a linked list node. Overloaded operators implement
the logic of accessing list nodes and values they contain.</p>
<p>Lets have a look at how our function for returning of an iterator which points to the maximum element of
a given data structure works for both arrays and linked lists:</p>
<pre class="code cpp literal-block">
<span class="n">LinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">l</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Max in list: &quot;</span>  <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Max in array: &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
</pre>
<h2>Conclusion</h2>
<p>This is only a small part of what you need to know about iterators. We've covered only one kind of iterators
- <strong>Forward Iterators</strong> which allows one to access elements moving forwards (using the <code>++</code> operator). There
are other kinds of iterators, e. g. <strong>Bidirectional Iterators</strong> which allows one to access elements moving
backwards too (<code>++</code>, <code>!=</code>, <code>*</code> operators are suplemented with <code>--</code> operator), etc.</p>
<p><code>C++</code> iterators use pointers semantics as their interface, but it's just an
implementation detail - any other interface could have been choosen. But the actual
implementation enables one to use raw pointers as iterators.</p>
<p>Iterators are a very important part of <code>STL</code> because they decouple algorithms from data structures
these algorithms work on. This way algorithms might be generalized to work with any data structure
as long as it provides the required kinds of iterators.</p>
<p>The source code of code snippets is available on <a class="reference external" href="https://github.com/malor/iterators-source">GitHub</a>.</p>

  <footer>
  
  
  </footer>
</article>

  </div> <!-- /#content -->
  </div> <!-- /.content-wrapper -->

  <div class="footer-wrapper">
  <footer class="footer">
    <p>&copy; 2018 Roman Podoliaka
</p>
  </footer>
  </div> <!-- /.footer-wrapper -->

  



<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37812430-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- /Google Analytics -->